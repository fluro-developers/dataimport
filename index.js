var _ = require('lodash');
var async = require('async');
var Papa = require('papaparse');
var Fluro = require('fluro');
var fs = require('fs');
var path = require('path');
var util = require('util');
var moment = require('moment-timezone');
var inquirer = require('inquirer');


///////////////////////////////////////////////////

//Timezone
//Often the imported data will have incorrect dates
//For example, the date will be provided in Australia/Sydney timezone
//but presented in the CSV as a UTC date. eg. 6am Sunday becomes 9am Monday morning
//So we can force the date stamps to be parsed in a particular timezone
var DATE_TIMEZONE = 'Australia/Sydney';
var DATE_FORMAT = 'YYYY-MM-DD HH:mm'; //Preferably UTC datestamp YYYY-MM-DD HH:MM


///////////////////////////////////////////////////
///////////////////////////////////////////////////

//COLUMN MAPPINGS
//this is where we need to specify the required column headings in the CSV

//Keys for checkin import data
var CHECKIN_CONTACT_EXTERNAL_ID = 'ElvantoMemberID'; //This should resolve to a unique id, (breeze id, or elvanto member id)
var CHECKIN_EVENT_EXTERNAL_ID = 'Event_ID'; //This should resolve to an id for the event (many other systems may not have a unique id for an event, so one may need to be generated by stringifying the date)
var CHECKIN_EVENT_DATE = 'Attendance_Date'; //This should resolve to the date of the event/checkin
var CHECKIN_EVENT_TITLE = 'Meeting'; //'Event Title';
var CHECKIN_CONTACT_FIRST_NAME = 'First_Name';
var CHECKIN_CONTACT_LAST_NAME = 'Last_Name';
var CHECKIN_CONTACT_DOB = 'Date_of_Birth';
var CHECKIN_CONTACT_GENDER = 'Gender';

//Keys for groups import data
var GROUP_EXTERNAL_ID = 'Group';
var GROUP_CONTACT_EXTERNAL_ID = 'Member ID'; //This should resolve to a unique id, (breeze id, or elvanto member id)
var GROUP_TITLE = 'Group'; //'Event Title';
var GROUP_POSITION = 'Position'; //'Event Title';
var GROUP_CONTACT_FIRST_NAME = 'First Name';
var GROUP_CONTACT_LAST_NAME = 'Last Name';
var GROUP_CONTACT_DOB = 'Date of Birth';
var GROUP_CONTACT_GENDER = 'Gender';


//Keys for Headcount import data
var HEADCOUNT_EVENT_DATE = 'Date'; //This should resolve to the date of the event
var HEADCOUNT_EVENT_EXTERNAL_ID = 'ElvantoEventID'; //This should resolve to an id for the event
var HEADCOUNT_EVENT_TITLE = 'Title'; //This should resolve to the title/name of the event
var HEADCOUNT_NUMBER = 'Total'; //This should resolve to the number of people at the event


//Keys for a contact
var NOTE_CONTACT_EXTERNAL_ID = 'ElvantoMemberID'; //This should resolve to a unique id for the person, (breeze id, or elvanto member id)
var NOTE_CONTACT_FIRST_NAME = 'First Name';
var NOTE_CONTACT_LAST_NAME = 'Last Name';
var NOTE_CONTACT_GENDER = 'Gender';
var NOTE_CONTACT_PHONE_NUMBER = 'Phone Number';
var NOTE_CONTACT_EMAIL_ADDRESS = 'Email Address';
var NOTE_CREATED_DATE = 'Created On';
var NOTE_AUTHOR_FIRST_NAME = 'Createdby_FirstName';
var NOTE_AUTHOR_LAST_NAME = 'Createdby_LastName';
var NOTE_MESSAGE = 'Notes';

///////////////////////////////////////////////////

//Map other important fields that are available in the CSV to fields in Fluro
var NOTE_EXTRA_FIELDS = [
    //  { from:'Some Important Column', to:'data.someCustomField' },
]

//Map other fields that are available in the CSV to fields in Fluro
var CONTACT_EXTRA_FIELDS = [
    //{ from:'Middle Name', to:'middleName' },
    //{ from:'Marital_Status', to:'maritalStatus' },
    //{ from:'Member_Create_Date', to:'created', date:true},
]

///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////









//How many should be imported at a time.
//Due to rate limiting we don't want this to be too high or the server will think we are DDOSSing it
var CONCURRENCY = 3;

///////////////////////////////////////////////////

//These just keep track of things we already know,
//during import. Eg. if we import a new contact with external id 'A' and it comes back with _id '4'.
//Then we don't need to go to the server to find out the id, because we cache it here
var cache = {};
var inflight = {};

///////////////////////////////////////////////////

//This keeps track of where we are at
var count = 0;
var total = 0;

//This is how many records to skip incase our import fails or stops
//We don't have to start from the start, (we can change this to 85000 or something)
var skip = 0;



///////////////////////////////////////////////////

//Create Fluro
var fluro = new Fluro({
    apiURL: 'staging',
});

///////////////////////////////////////////////////

//Go through the steps
return async.waterfall([
    login, //Login to Fluro
    selectAccount, //Select the account
    loadFiles, //Load the CSV files
    chooseFile, //Select the CSV file
    loadCSV, //Load it up 
    importRows, //Start the import
], done)

///////////////////////////////////////////////////

function login(next) {

    inquirer.prompt([{
                type: 'input',
                message: 'Type your Fluro user email address',
                name: 'username',
            },
            {
                type: 'password',
                message: 'Enter your password',
                name: 'password',
            },
        ])
        .then(answers => {

            //Login to Fluro
            fluro.auth.login(answers)
                .then(function(res) {
                    console.log('Logged in as', res.data.firstName, res.data.lastName)
                    return next();
                })
                .catch(function(err) {

                    console.log('Authentication Failed', fluro.utils.errorMessage(err));
                    return login(next);
                });
        })
}

///////////////////////////////////////////////////

function selectAccount(next) {


    console.log('Loading accounts...')
    fluro.api.get('/user/accounts').then(accountListLoaded, next)

    /////////////////////////////

    function accountListLoaded(res) {

        var choices = _.chain(res.data)
            .map(function(account) {
                return {
                    name: `${account.title}`,
                    value: account._id,
                }
            })
            .orderBy('name')
            .value();


        /////////////////////////////

        var userSession = fluro.auth.getCurrentUser();
        var currentAccount = userSession.account;

        /////////////////////////////

        choices = [{
                name: `${currentAccount.title}`,
                value: currentAccount._id,
            },
            new inquirer.Separator(),
        ].concat(choices)

        /////////////////////////////

        inquirer.prompt([{
                type: 'list',
                name: 'account',
                message: 'Please select your account',
                choices,
            }])
            .then(function(answers) {
                fluro.auth.changeAccount(answers.account).then(function(res) {
                    console.log(`Signed in to ${res.data.account.title}`)
                    return next();
                }, next)

            }, next);
    }
}
///////////////////////////////////////////////////


function loadFiles(next) {

    return walk('./files', next);

    /////////////////////

    function walk(dir, done) {
        var results = [];
        fs.readdir(dir, function(err, list) {
            if (err) return done(err);
            var pending = list.length;
            if (!pending) return done(null, results);
            list.forEach(function(file) {
                file = path.resolve(dir, file);
                fs.stat(file, function(err, stat) {
                    if (stat && stat.isDirectory()) {
                        walk(file, function(err, res) {
                            results = results.concat(res);
                            if (!--pending) done(null, results);
                        });
                    } else {
                        results.push(file);
                        if (!--pending) done(null, results);
                    }
                });
            });
        });
    }

}


function chooseFile(files, next) {


    var choices = _.chain(files)
        .map(function(file) {

            var pieces = file.split('/');
            return {
                name: pieces[pieces.length - 1],
                value: file,
            }
        })
        .orderBy('name')
        .value();

    /////////////////////////////

    inquirer.prompt([{
            type: 'list',
            name: 'file',
            message: 'Select file to import',
            choices,
        }])
        .then(function(answers) {
            return next(null, answers.file);
        }, next);
}

///////////////////////////////////////////////////

function loadCSV(filename, next) {

    console.log(`Loading CSV file (${filename})`);
    console.log('Parsing...')
    var results = [];

    /////////////////////////////////////////////

    var readStream = fs.createReadStream(filename);
    Papa.parse(readStream, {
        header: true,
        complete: function() {

            total = results.length;

            if (skip) {
                console.log(`${total} rows in total`)
                console.log(`Skipping ${skip} rows`)
                count = skip;
                results = results.slice(skip)
            }


            console.log(`${total} rows to import`)

            //We've loaded all the rows
            return next(null, results);
        },
        step: function(result) {
            result.data.index = results.length;
            results.push(result.data);
        },
        error: next,
    })
}




function importRows(rows, next) {

    console.log('Loading Realms...');

    fluro.api.get('/realm/selectable', {
            params: {
                flat: true
            }
        })
        .then(function(res) {

            // console.log('REALMS LOADED', res.data);

            var choices = _.chain(res.data)
                .map('realms')
                .flatten()
                .filter(function(realm) {
                    return realm.status != 'archived' && !realm._discriminator && !realm._discriminatorType && !realm._team;
                })
                .map(function(realm) {

                    // var pieces = file.split('/');
                    return {
                        name: realm.title,
                        value: realm._id,
                    }
                })
                .orderBy(function(realm) {
                    return String(realm.name).toLowerCase();
                })
                .value();

            /////////////////////////////

            inquirer.prompt([{
                    type: 'list',
                    name: 'operation',
                    message: 'What kind of data are you importing?',
                    choices: [{
                            name: 'People Notes',
                            value: 'notes',
                        },
                        {
                            name: 'Checkins / Attendance',
                            value: 'checkins',
                        },

                        {
                            name: 'Groups / Teams',
                            value: 'groups',
                        },

                        {
                            name: 'Attendance Headcounts',
                            value: 'headcount',
                        },

                        /**
                        //Here is where you can come up with your own option to present to the user
                        {
                            name: 'CUSTOM IMPORT',
                            value: 'customImportKey',
                        }
                        /**/
                    ],
                }])
                .then(function(importQuestions) {


                    /////////////////////////////////////////////////

                    inquirer.prompt([{
                            type: 'list',
                            name: 'realm',
                            message: 'Select which realm to import to',
                            choices,
                        }])
                        .then(function(answers) {


                            /////////////////////////////////////////////////

                            var importFunction;

                            switch (importQuestions.operation) {
                                case 'checkins':
                                    //We need to group all the checkins into events
                                    return groupAndImportCheckins(rows, answers.realm, next);
                                    break;

                                case 'notes':
                                    return async.eachLimit(rows, CONCURRENCY, function(row, next) {
                                        return importNote(row, answers.realm, next);
                                    }, next);
                                    break;
                                case 'groups':
                                    return groupAndImportGroupMembers(rows, answers.realm, next);
                                    break;
                                case 'headcount':
                                    //We need to group all the entries into events
                                    return async.eachLimit(rows, CONCURRENCY, function(row, next) {
                                        // console.log('ROW', row);
                                        // return next();
                                        return importHeadcountEvent(row, answers.realm, next);
                                    }, next);
                                    break;
                                    /**
                                                                    case 'customImportKey':
                                                                        //We need to group all the checkins into events
                                                                        return yourCustomImportFunction(rows, answers.realm, next);
                                                                        break;
                                                                        /**/
                                default:
                                    return next('Invalid option');
                                    break;
                            }



                        }, next);



                }, next);

            /////////////////////////////


        }, next)
}

///////////////////////////////////////////////////

//Come up with your custom setup for importing
function yourCustomImportFunction(rows, realm, next) {
    return next();
}


///////////////////////////////////////////////////

function importHeadcountEvent(row, defaultRealm, next) {



    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////



    //Get the value for the headcount
    var headcount = _.get(row, HEADCOUNT_NUMBER) ? parseInt(_.get(row, HEADCOUNT_NUMBER)) : 0;

    if (!headcount) {
        return next();
    }


    //Find the unique external id for the event
    var externalParentID = getExternalEventID(row, 'headcount');

    //Get the title of the event
    var eventTitle = _.get(row, HEADCOUNT_EVENT_TITLE);

    //Get the date
    var length = '2015-05-31T18:00:00';
    var dateString = _.get(row, HEADCOUNT_EVENT_DATE).slice(length);
    var startDate = getDate(dateString, DATE_FORMAT, DATE_TIMEZONE);

    //Create a unique id for the headcount
    var headCountExternalID = `${externalParentID}-headcount`;

    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    async.waterfall([
        function(next) {

            var newEvent = {
                _type: 'event',
                status: 'archived',
                _external: externalParentID,
                title: eventTitle,
                realms: [defaultRealm],
                startDate,
            }

            //Get the event if we have already created it or create a new event 
            //in Fluro
            return findOrCreate(externalParentID, newEvent, null, next);
        },
        function(eventID, next) {

            var newPost = {
                _type: 'attendance',
                title: eventTitle,
                event: eventID,
                count: headcount,
                data: {
                    imported: row,
                },
                realms: [defaultRealm],
                _external: headCountExternalID,
            }

            //Let just track how long it takes to create
            var key = `Importing (${count+1}/${total}) ${newPost._id} ${newPost._external}`;
            console.time(key)


            return findOrCreate(headCountExternalID, newPost, null, function(err, result) {
                count++;
                console.timeEnd(key)


                return next(err, result);
            });
        }
    ], function(err, result) {

        if (err) {
            console.log('Failed', err);
        }

        return next(null, result);
    })
}

///////////////////////////////////////////////////

function groupAndImportGroupMembers(rows, realm, next) {

    /////////////////////////////

    var grouped = _.reduce(rows, function(set, row) {

        var externalGroupID = getExternalGroupID(row);

        /////////////////////////////

        var groupingKey = externalGroupID;
        var existing = set[groupingKey];
        if (!existing) {
            existing = set[groupingKey] = {
                externalGroupID,
                members: [],
                realm,
                row,
            }
        }

        existing.members.push(row);

        /////////////////////////////

        return set;
    }, {});

    /////////////////////////////


    return async.eachLimit(grouped, 1, function(group, next) {
        return importGroupMembers(group, realm, next);
    }, next);

}



function groupAndImportCheckins(rows, realm, next) {

    /////////////////////////////

    var grouped = _.reduce(rows, function(set, row) {

        var externalEventID = getExternalEventID(row, 'checkin');

        /////////////////////////////

        var groupingKey = externalEventID;
        var existing = set[groupingKey];
        if (!existing) {
            existing = set[groupingKey] = {
                externalEventID,
                checkins: [],
                realm,
                row,
            }
        }

        existing.checkins.push(row);

        /////////////////////////////

        return set;
    }, {});

    /////////////////////////////


    return async.eachLimit(grouped, 1, function(group, next) {
        return importEventCheckins(group, realm, next);
    }, next);

}

///////////////////////////////////////////////////
///////////////////////////////////////////////////

function getExternalGroupID(row) {
    var externalGroupID = row[GROUP_EXTERNAL_ID] || _.get(row, GROUP_EXTERNAL_ID);

    if (!externalGroupID) {
        console.log('INVALID OR COULD NOT MAP EXTERNAL GROUP ID! CSV MAY BE CORRUPTED OR EVENT EXTERNAL ID PATH IS INCORRECT')
        return process.exit();
    }

    return externalGroupID;

}

///////////////////////////////////////////////////

function getExternalEventID(row, type) {

    // var externalEventDate = new Date(_.get(row, 'Date'));
    // var externalEventID = `event-${_.get(row, 'EventID')}-${externalEventDate.getTime()}`;

    var externalEventID;

    switch (type) {
        case 'headcount':
            externalEventID = row[HEADCOUNT_EVENT_EXTERNAL_ID] || _.get(row, HEADCOUNT_EVENT_EXTERNAL_ID);
            break;
        case 'checkin':
            externalEventID = row[CHECKIN_EVENT_EXTERNAL_ID] || _.get(row, CHECKIN_EVENT_EXTERNAL_ID);
            // console.log('GET THE EXTERNAL EVENT ID', externalEventID, CHECKIN_EVENT_EXTERNAL_ID, row, row['Event_ID'], _.keys(row));
            break;
    }


    if (!externalEventID) {
        console.log(`INVALID OR COULD NOT MAP EXTERNAL EVENT ID! CSV MAY BE CORRUPTED OR EVENT EXTERNAL ID PATH IS INCORRECT`)
        return process.exit();
    }



    return externalEventID;
}


function getExternalContactID(row, type) {

    var externalContactID;

    switch (type) {
        case 'note':
            externalContactID = _.get(row, NOTE_CONTACT_EXTERNAL_ID);
            break;
        case 'checkin':
            externalContactID = _.get(row, CHECKIN_CONTACT_EXTERNAL_ID);
            break;
    }


    if (!externalContactID) {
        console.log('INVALID OR COULD NOT MAP EXTERNAL CONTACT ID! CSV MAY BE CORRUPTED OR CONTACT EXTERNAL ID PATH IS INCORRECT')
        return process.exit();
    }

    return externalContactID;
}


//Import an event with all of it's checkins
function importGroupMembers(group, defaultRealm, next) {

    //Get the External ID of the event
    var externalGroupID = group.externalGroupID;

    //////////////////////////////////////////////

    //If we cant find the group
    //we need to create it
    var row = group.row;

    //////////////////////////////////////////////

    //Add tags
    // var tags = _.get(row, 'Categories');
    // if (tags && tags.length) {
    //     tags = _.chain(splitString(tags, ',|;'))
    //         .compact()
    //         .map(function(string) {
    //             return string.trim();
    //         })
    //         .compact()
    //         .uniq()
    //         .value();
    // }

    //////////////////////////////////////////////

    var newGroup = {
        title: `${_.get(row, GROUP_TITLE)}`,
        _external: externalGroupID,
        _type: 'team',
        // tags: tags,
        realms: [defaultRealm],
        data: {
            groupImport: row,
        },
        provisionalMembers: [],
    }

    ///////////////////////////////////////

    var assignmentRows = {};
    var requiresMerge = _.get(row, 'Merge') || _.get(row, 'merge');
    console.log('Requires Merge!', requiresMerge, row.title);

    ///////////////////////////////////////

    return async.eachLimit(group.members, CONCURRENCY, function(member, next) {

        //Get all the details for the contact
        var contactExternalID = _.get(member, GROUP_CONTACT_EXTERNAL_ID);
        var firstName = _.get(member, GROUP_CONTACT_FIRST_NAME);
        var lastName = _.get(member, GROUP_CONTACT_LAST_NAME);
        var dob = _.get(member, GROUP_CONTACT_DOB);
        var gender = _.get(member, GROUP_CONTACT_GENDER);
        var position = _.get(member, GROUP_POSITION);

        // //Keys for groups import data
        // var GROUP_EXTERNAL_ID = 'Group';
        // var GROUP_CONTACT_EXTERNAL_ID = 'Member ID'; //This should resolve to a unique id, (breeze id, or elvanto member id)
        // var GROUP_TITLE = 'Group'; //'Event Title';
        // var GROUP_POSITION = 'Position'; //'Event Title';
        // var GROUP_CONTACT_FIRST_NAME = 'First Name';
        // var GROUP_CONTACT_LAST_NAME = 'Last Name';
        // var GROUP_CONTACT_DOB = 'Date of Birth';
        // var GROUP_CONTACT_GENDER = 'Gender';

        var contactData = {
            firstName,
            lastName,
            dob: dob ? new Date(dob) : undefined,
            gender,
            _type: 'contact',
            realms: [defaultRealm],
            _external: contactExternalID,
        }


        return findOrCreate(contactExternalID, contactData, null, function(err, contactID) {
            if (err) {
                return next();
            }

            //Add the contact to the provisional members
            if (!position || !position.length) {
                newGroup.provisionalMembers.push(contactID);
                return next();
            }

            //Add the contact to the relevant assignment row
            var positionKey = _.camelCase(position);
            if (!assignmentRows[positionKey]) {
                assignmentRows[positionKey] = {
                    title: position,
                    contacts: [],
                }
            }

            ////////////////////////////
            assignmentRows[positionKey].contacts.push(contactID);

            return next();

        });


        // //Use the fluro event id
        // checkinData.event = eventID;
        // return importCheckin(checkinData, defaultRealm, next);
    }, function(err, results) {
        if (err) {
            return next(err);
        }

        //Now we should have all the bits to create the group
        newGroup.assignments = _.values(assignmentRows);

        console.log('Create Group')
        return findOrCreate(externalGroupID, newGroup, { merge: requiresMerge }, function(err, groupID) {
            if (err) {
                console.log('skip group due to error', err);
                return next();
                // return next(err);
            }

            console.log('---- Create Group', groupID, newGroup.provisionalMembers.length, 'members', newGroup.assignments.length, 'assignments');
            return next();
        });
    });
}

//Import an event with all of it's checkins
function importEventCheckins(group, defaultRealm, next) {

    //Get the External ID of the event
    var externalEventID = group.externalEventID;

    //////////////////////////////////////////////

    //If we cant find the event
    //we need to create it

    var row = group.row;

    var length = '2015-05-31T18:00:00';
    var dateString = _.get(row, CHECKIN_EVENT_DATE).slice(length);
    var date = getDate(dateString, DATE_FORMAT, DATE_TIMEZONE);


    // var date = dateString && dateString.length ? new Date(dateString) : null;
    if (!date) {
        return next('Invalid date for event');
    } else {
        // console.log('NEW DATE', date)
        // return next('FAIL')
    }

    //////////////////////////////////////////////

    var tags = _.get(row, 'Categories');
    if (tags && tags.length) {
        tags = _.chain(splitString(tags, ',|;'))
            .compact()
            .map(function(string) {
                return string.trim();
            })
            .compact()
            .uniq()
            .value();
    }

    //////////////////////////////////////////////

    var newItem = {
        title: `${_.get(row, CHECKIN_EVENT_TITLE)}`,
        _external: externalEventID,
        _type: 'event',
        tags: tags,
        startDate: date,
        realms: [defaultRealm],
        data: {
            attendanceImport: row,
        }
    }

    ///////////////////////////////////////////////////////////

    //Create/Find the event
    return findOrCreate(externalEventID, newItem, null, function(err, eventID) {
        if (err) {
            console.log('skip event due to error', err);
            return next();
            // return next(err);
        }

        console.log('---- Create Event', eventID, newItem.title, group.checkins.length);

        //////////////////////////////////////////////////

        return async.eachLimit(group.checkins, CONCURRENCY, function(checkinData, next) {
            //Use the fluro event id
            checkinData.event = eventID;
            return importCheckin(checkinData, defaultRealm, next);
        }, next);


    })
}

///////////////////////////////////////////////////

function findOrCreate(externalID, newItem, options, next) {

    if (!options) {
        options = {}
    }


    var type = newItem.definition || newItem._type;


    ////////////////////////////////////////////////

    if (!inflight[externalID]) {

        ////////////////////////////////////////////////

        inflight[externalID] = new Promise(function(resolve, reject) {

            //Ensure that this is set on the new item
            newItem._external = externalID;

            ////////////////////////////////////////////////


            if (!type) {
                console.log('NO TYPE!', newItem)
                return reject('Cant create an item without a _type or definition');
            }

            if (options.merge) {
                console.log('Requires Merge')
                //We need to merge so skip the external id checking
                return createItem();
            }

            ////////////////////////////////////////////////


            //First check to see if the external id already exists in Fluro
            return fluro.api(`/check/external/${externalID}`)
                .then(function(res) {

                    //Cache the Fluro ID so it's faster to lookup later on
                    var fluroID = res.data._id;
                    cache[externalID] = fluroID;

                    //Continue onward
                    return resolve(fluroID);

                }, function(err) {

                    // console.log('CHECK ERROR', err);

                    return createItem(err);
                });

            ////////////////////////////////////////////////

            function createItem(err) {

                if (err) {
                    if (!err.response) {
                        console.log('BIG FAILED ISSUE', err);
                        return reject('BIG FAIL');
                    }


                    if (err.response.status != 404) {
                        console.log('IMPORT ERROR', type, err.response.status, err.response.statusText, err.response.data);
                        // console.log(`Count not find event with external id: ${externalEventID}`, row)
                        return reject(err);
                    }
                }

                //////////////////////////////////////////////

                var shouldNotMergeAndForceCreate = (newItem.merge || options.merge) ? undefined : true;

                console.log('IMPORTING NO MERGE?', newItem.title, shouldNotMergeAndForceCreate)
                return fluro.api.post('/content/_import', newItem, {
                        params: {
                            noMerge:shouldNotMergeAndForceCreate,
                            title: newItem.title,
                        }
                    })
                    .then(function(response) {
                        return resolve(response.data._id);
                    })
                    .catch(function(err) {
                        console.log(`CREATE ${type} ERROR`, err.response.status, err.response.statusText, err.response.data, newItem);
                        return reject(err);
                    });
            }


        })
    } else {
        //console.log('-- existing inflight request', externalID)
    }


    inflight[externalID]
        .then(function(itemID) {
            //console.log('Created', type, newItem.title, itemID)
            return next(null, itemID);
        })
        .catch(function(err) {
            //console.log('BIG ERROR HERE', err);
            return next(err);
        })

}

///////////////////////////////////////////////////


function importCheckin(row, defaultRealm, done) {

    count++;

    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    //Get the pieces for the event
    var externalPersonID = getExternalContactID(row, 'checkin');

    var length = '2015-05-31T18:00:00';
    var dateString = _.get(row, CHECKIN_EVENT_DATE).slice(length);
    var externalEventDate = getDate(dateString, DATE_FORMAT, DATE_TIMEZONE);

    // var externalEventDate = new Date(_.get(row, 'Date'));

    //////////////////////////////////////////////////
    //////////////////////////////////////////////////    
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    async.parallel([
        findContact,
    ], createCheckin);

    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    function findContact(next) {

        var newContact = {
            _external: externalPersonID,
            _type: 'contact',
            firstName: `${_.get(row, CHECKIN_CONTACT_FIRST_NAME)}`,
            lastName: `${_.get(row, CHECKIN_CONTACT_LAST_NAME)}`,
            dob: `${_.get(row, CHECKIN_CONTACT_DOB)}`,
            gender: `${_.get(row, CHECKIN_CONTACT_GENDER)}`,
            //maritalStatus: `${_.get(row, CHECKIN_CONTACT_MARITAL, 'Marital_Status')}`,
            //created: `${_.get(row, CHECKIN_CONTACT_CREATED_DATE, 'Member_Create_Date')}`,
            realms: [defaultRealm],
            data: {
                attendanceImport: row,
            },
            status: 'draft',
        }

        return findOrCreate(externalPersonID, newContact, null, function(err, contactID) {
            if (err) {
                return done();
            }

            return next(null, contactID);
        });
    }


    //////////////////////////////////////////////////

    function createCheckin(err, pieces) {
        if (err) {
            console.log('Could not create checkin', pieces);
            return next();
        }

        var contact = pieces[0];
        var event = row.event;

        if (!contact) {
            console.log('Could not create checkin, No contact', err);
            return next();
        }

        //////////////////////////////////////////////

        var externalCheckinID = `${event}-${contact}-checkin`;

        //////////////////////////////////////////////

        var length = '2015-05-31T18:00:00';
        var dateString = _.get(row, CHECKIN_EVENT_DATE).slice(length);
        var date = getDate(dateString, DATE_FORMAT, DATE_TIMEZONE);

        //////////////////////////////////////////////

        var newCheckinItem = {
            _external: externalCheckinID,
            _type: 'checkin',
            title: `${_.get(row, CHECKIN_CONTACT_FIRST_NAME)} ${_.get(row, CHECKIN_CONTACT_LAST_NAME) || 'Unknown'}`,
            contact,
            event,
            realms: [defaultRealm],
            data: row,
            created: date,
        }

        //////////////////////////////////////////////

        console.log(`>>>>> Importing checkin ${count} / ${total}`, row.event, externalPersonID)

        return findOrCreate(externalCheckinID, newCheckinItem, null, function(err, checkinID) {

            if (err) {
                return done(null, checkinID);
            }

            return done(err, checkinID);
        });

    }
}


///////////////////////////////////////////////////


///////////////////////////////////////////////////

function importNote(row, defaultRealm, next) {


    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    //Find the parent by it's attached member ID
    var externalParentID = getExternalContactID(row, 'note');

    //////////////////////////////////////////////////
    //////////////////////////////////////////////////
    //////////////////////////////////////////////////

    var firstName = _.get(row, NOTE_CONTACT_FIRST_NAME);
    var lastName = _.get(row, NOTE_CONTACT_LAST_NAME);

    async.waterfall([
        function(next) {

            var newContact = {
                _type: 'contact',
                _external: externalParentID,
                firstName,
                lastName,
                gender: _.get(row, NOTE_CONTACT_GENDER) || 'unknown',
                status: 'draft',
                phoneNumbers: _.compact([_.get(row, NOTE_CONTACT_PHONE_NUMBER)]),
                emails: _.compact([_.get(row, NOTE_CONTACT_EMAIL_ADDRESS)]),
                realms: [defaultRealm],
            }


            _.each(CONTACT_EXTRA_FIELDS, function(mapping) {
                mapValue(row, newContact, mapping.from, mapping.to);
            })




            ///////////////////////////

            if (!newContact.phoneNumbers.length && !newContact.emails.length) {
                newContact.status = 'draft';
            }

            ///////////////////////////

            return findOrCreate(externalParentID, newContact, null, next);
        },
        function(parent, next) {


            //Get the date
            var length = '2015-05-31T18:00:00';

            var dateString = (_.get(row, NOTE_CREATED_DATE) || '').slice(length);
            var created = getDate(dateString, DATE_FORMAT, DATE_TIMEZONE);



            /////////////////////////////////////

            var newPost = {
                _type: 'post',
                created,
                parent,
                data: {
                    imported: row,
                },
                definition: 'note',
                realms: [defaultRealm],
            }

            /////////////////////////////////////

            var authorFirstName = _.get(row, NOTE_AUTHOR_FIRST_NAME);
            var authorLastName = _.get(row, NOTE_AUTHOR_LAST_NAME);

            var authorName = `${authorFirstName || ''} ${authorLastName || ''}`;


            newPost.title = authorName ? `${authorName} Wrote a note` : 'Note';
            mapValue(row, newPost, NOTE_MESSAGE, 'data.body');


            _.each(NOTE_EXTRA_FIELDS, function(mapping) {
                mapValue(row, newPost, mapping.from, mapping.to);
            })

            /////////////////////////////////////

            //Create a Unique ID
            var start = `note-import-${dateString}-${authorName}-${firstName}-${lastName}-${newPost.title}`;
            var firstThreeCharacters = (_.get(row, NOTE_MESSAGE) || '').slice(0, 50);
            var externalID = String(`${start}-${firstThreeCharacters}`).toLowerCase();
            newPost._external = externalID;


            // console.log('--------')
            var key = `Importing Note (${count+1 }/${total}) ${firstName} ${lastName} - ${parent}`;
            // console.log(key)
            // console.time(key)


            return findOrCreate(externalID, newPost, null, function(err, result) {


                // console.timeEnd(key)
                if (err) {
                    console.log('ERROR CREATING', err);
                } else {
                    console.log('created note', firstName, lastName, result, 'ext:', externalParentID)
                }
                count++;


                return next(err, result);
            });
        }
    ], function(err, result) {

        if (err) {
            console.log('Failed', err);
        }

        return next(null, result);
    })
}

///////////////////////////////////////////////////

function splitString(source, splitBy) {
    var splitter = splitBy.split('');
    splitter.push([source]); //Push initial value

    return splitter.reduceRight(function(accumulator, curValue) {
        var k = [];
        accumulator.forEach(v => k = [...k, ...v.split(curValue)]);
        return k;
    });
}


///////////////////////////////////////////////////

function mapValue(input, output, from, to, defaultValue) {
    var value = _.get(input, from);


    if (!value) {
        if (defaultValue) {
            value = defaultValue;
        } else {
            return;
        }
    }

    _.set(output, to, value);
}



// ///////////////////////////////////////////////////




// ///////////////////////////////////////////////////

// async.waterfall([
//     loginToFluro,
//     loadCSV,
//     formatAndSendRows,
// ], done);


// ///////////////////////////////////////////////////

// function loginToFluro(next) {
//     console.log('Login to Fluro')

//     fluro.auth.login({
//             username: answers.username,
//             password: answers.password,
//         })
//         .then(function(res) {
//             console.log('Logged in!', res.data.firstName, res.data.lastName)
//             return next();
//         }, next)
// }

// ///////////////////////////////////////////////////

// function loadCSV(next) {
//     return ('Failed on purpose');

//     console.log('Load the CSV');
//     var results = [];

//     /////////////////////////////////////////////

//     var readStream = fs.createReadStream('notes.csv');
//     Papa.parse(readStream, {
//         header: true,
//         complete: function() {

//             results = _.sortBy(results, function(row) {
//                 return _.get(row, 'Member ID');
//             })

//             return next(null, results);
//         },
//         step: function(result) {
//             result.data.index = results.length;
//             results.push(result.data);
//             // console.log('parsed', results.length);
//         },
//         error: next,
//     })
// }

// ///////////////////////////////////////////////////

// function formatAndSendRows(data, next) {

//     if (start) {
//         data = data.slice(start);
//     }

//     console.log('Importing', data.length);

//     //Do 5 at a time with a short break in between
//     async.mapLimit(data, CONCURRENCY, formatAndSend, function(err, formatted) {
//         if (err) {
//             return next(err);
//         }


//         // setTimeout(function() {
//         return next(null, formatted);
//         // }, 500);

//     });
// }

function getDate(dateString, format, timezone) {

    if (timezone) {
        return moment.tz(dateString, format, DATE_TIMEZONE).toDate();
    } else {
        return moment(dateString, format).toDate();
    }
}


///////////////////////////////////////////////////

function done(err, result) {

    if (err) {
        console.log('FAILED', err);
    } else {
        console.log('ALL DONE', result);
    }
}



// ///////////////////////////////////////////////////


// var created = 0;

// function formatAndSend(row, next) {

//     var createdDate = _.get(row, 'Note Date');
//     var output = {
//         _type: 'post',
//         created: new Date(createdDate),
//         data: {
//             imported: row,
//         },
//     }





//     async.parallel([
//         getParent,
//     ], function(err) {

//         if (err || !output.parent) {
//             console.log('ERROR -> COULD NOT FIND', row)
//             return next();
//         }



//         ///////////////

//         //Map the fields to the correct fluro field
//         mapValue(row, output, 'Notes', 'data.body');

//         //Find out if it's private
//         var isPrivate = _.get(row, 'Private') == 'Yes';

//         //////////////////////////////////////////////////

//         //Find out what category it is in
//         switch (_.get(row, 'Categories')) {
//             case 'Prayer Request':
//                 _.set(output, 'data.type', 'Prayer Request');
//                 output.definition = 'prayerPraiseReport';
//                 mapValue(row, output, 'Notes', 'data.details');
//                 break;
//             case 'Praise Report':
//                 _.set(output, 'data.type', 'Praise Report');
//                 output.definition = 'prayerPraiseReport';
//                 mapValue(row, output, 'Notes', 'data.details');
//                 break;
//                 // case 'Pastoral Care':
//                 // case 'Invitation to Connect':
//                 // case 'General':
//             default:
//                 output.definition = 'comment';
//                 break;
//         }

//         output.title = `${_.get(row, 'Created By')} - ${createdDate}`;

//         //////////////////////////////////////////////////

//         //If it's private then map to a private note
//         if (isPrivate) {
//             output.definition = 'note';
//             output.realms = ['5c747ff79914f817612057e4'];
//         } else {
//             //otherwise put it in the church life realm
//             output.realms = ['5b72415ca9f54b1854a18a16'];
//         }

//         //////////////////////////////////////////////////

//         //Create a Unique ID
//         var start = `elvanto-import-${output.parent}-${_.kebabCase(createdDate)}`;
//         var firstThreeCharacters = _.kebabCase((_.get(output, 'data.details') || _.get(output, 'data.body')).slice(0, 50));
//         var externalID = `${start}-${firstThreeCharacters}`;

//         output._external = externalID;

//         var matched = _.find(checks, function(row) {
//             return row._external == externalID;
//         })

//         if (!matched) {
//             console.log('>>>>>> NO MATCH', externalID);
//             return next();
//         } else {
//             // console.log(created++, 'already matched');
//             return next();
//         }
//         // console.log('EXTERNAL', externalID);
//         // return;
//         // console.log('OUTPUT', output);

//         ///////////////

//         // console.time(`${row.index} ${output.parent} -                      imported in`)
//         //Post the content!
//         fluro.api.post('/content/_import', output, {
//                 params: {
//                     noMerge: true,
//                     title: output.title,
//                 }
//             })
//             .then(function(response) {

//                 // console.log('__________________________');
//                 console.log('imported', created++, response.data._id);
//                 // console.timeEnd(`${row.index} ${output.parent} -                      imported in`)
//                 return next(null, output);
//             })
//             .catch(function(err) {
//                 console.log('error', err);
//                 return next(err);
//                 // console.timeEnd('imported in')
//             });



//         // return next(null, output);
//     })

//     ///////////////

//     //Find the parent in Fluro so we can connect the note
//     function getParent(parentMatched) {

//         //Find the parent by it's attached member ID
//         var externalParentID = _.get(row, 'Member ID')


//         //We already know the ID
//         if (cache[externalParentID]) {
//             // console.log('SKIPPED', externalParentID)
//             output.parent = cache[externalParentID]
//             return parentMatched();
//         }

//         // console.log('check external id', externalParentID);
//         // We need to talk to Fluro to find out the ID
//         fluro.api(`/check/external/${externalParentID}`)
//             .then(function(res) {

//                 // console.log('checked external id', res.data._id);
//                 cache[externalParentID] = res.data._id;
//                 output.parent = cache[externalParentID];
//                 // console.log('Matched', externalParentID, cache[externalParentID])
//                 return parentMatched();
//             }, function(err) {
//                 return next();
//             });


//         // //We need to talk to Fluro to find out the ID
//         // fluro.content.external(externalParentID, { select: 'title' })
//         // .then(function(res) {
//         //     cache[externalParentID] = res._id;
//         //     output.parent = cache[externalParentID];
//         //     // console.log('Matched', externalParentID, cache[externalParentID])
//         //     return next();
//         // },function(err) {
//         //     // console.log('ERROR LOADING EXTERNAL', err);
//         //     return next();
//         // });
//     }


// }

// ///////////////////////////////////////////////////
// ///////////////////////////////////////////////////

// function mapValue(input, output, from, to) {
//     var value = _.get(input, from);

//     if (!value) {
//         return;
//     }

//     _.set(output, to, value);
// }